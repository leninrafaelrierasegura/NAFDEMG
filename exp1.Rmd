---
title: "Experiment"
date: "Last modified: `r format(Sys.time(), '%d-%m-%Y.')`"
output:
  html_document:
    mathjax: "https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
    highlight: pygments
    theme: flatly
    code_folding: hide # class.source = "fold-hide" to hide code and add a button to show it
    df_print: paged
    # toc: true
    # toc_float:
    #   collapsed: true
    #   smooth_scroll: true
    number_sections: false
    fig_caption: true
    code_download: true
    css: visual.css
always_allow_html: true
bibliography: 
  - references.bib
  - grateful-refs.bib
header-includes:
  - \newcommand{\ar}{\mathbb{R}}
  - \newcommand{\llav}[1]{\left\{#1\right\}}
  - \newcommand{\pare}[1]{\left(#1\right)}
  - \newcommand{\Ncal}{\mathcal{N}}
  - \newcommand{\Vcal}{\mathcal{V}}
  - \newcommand{\Ecal}{\mathcal{E}}
  - \newcommand{\Wcal}{\mathcal{W}}
---


<div style="color: #2c3e50; text-align: right;">
********  
<strong>Press Show to reveal the code chunks.</strong>  

********
</div>


Let us set some global options for all code chunks in this document.


```{r}
# Create a clipboard button
source(here::here("clipboard.R")); clipboard
# Set seed for reproducibility
set.seed(1982) 
# Set global options for all code chunks
knitr::opts_chunk$set(
  # Disable messages printed by R code chunks
  message = FALSE,    
  # Disable warnings printed by R code chunks
  warning = FALSE,    
  # Show R code within code chunks in output
  echo = TRUE,        
  # Include both R code and its results in output
  include = TRUE,     
  # Evaluate R code chunks
  eval = TRUE,       
  # Enable caching of R code chunks for faster rendering
  cache = FALSE,      
  # Align figures in the center of the output
  fig.align = "center",
  # Enable retina display for high-resolution figures
  retina = 2,
  # Show errors in the output instead of stopping rendering
  error = TRUE,
  # Do not collapse code and output into a single block
  collapse = FALSE
)
# Start the figure counter
fig_count <- 0
# Define the captioner function
captioner <- function(caption) {
  fig_count <<- fig_count + 1
  paste0("Figure ", fig_count, ": ", caption)
}
```



```{r}
# remotes::install_github("davidbolin/rspde", ref = "devel")
# remotes::install_github("davidbolin/metricgraph", ref = "devel")
library(rSPDE)
library(MetricGraph)
library(grateful)

library(ggplot2)
library(reshape2)
library(plotly)
```



```{r}
capture.output(
  knitr::purl(here::here("functionality.Rmd"), output = here::here("functionality.R")),
  file = here::here("purl_log.txt")
)
source(here::here("functionality.R"))
```



```{r}
T_final <- 2
time_step <- 0.001 
h <- 0.001 
kappa <- 15
alpha <- 0.5 
m = 1
beta <- alpha/2
N_finite = 4 # choose even
adjusted_N_finite <- N_finite + N_finite/2 + 1
# Coefficients for u_0 and f
coeff_U_0 <- 50*(1:adjusted_N_finite)^-1
coeff_U_0[-5] <- 0
coeff_FF <- rep(0, adjusted_N_finite)
coeff_FF[7] <- 10


time_seq <- seq(0, T_final, by = time_step)
graph <- gets.graph.tadpole(h = h)
graph$compute_fem()
G <- graph$mesh$G
C <- graph$mesh$C
L <- kappa^2*C + G
I <- Matrix::Diagonal(nrow(C))

eigen_params <- gets.eigen.params(N_finite = N_finite, kappa = kappa, alpha = alpha, graph = graph)
EIGENVAL_ALPHA <- eigen_params$EIGENVAL_ALPHA
EIGENFUN <- eigen_params$EIGENFUN

AAA = 1
OMEGA = pi

U_0 <- EIGENFUN %*% coeff_U_0

U_true <- EIGENFUN %*% 
  outer(1:length(coeff_U_0), 
        1:length(time_seq), 
        function(i, j) (coeff_U_0[i] + coeff_FF[i] * G_sin(t = time_seq[j], A = AAA, lambda_j_alpha_half = EIGENVAL_ALPHA[i], omega = OMEGA) ) * exp(-EIGENVAL_ALPHA[i] * time_seq[j]))

overkill_graph <- gets.graph.tadpole(h = 0.0001)
overkill_graph$compute_fem()
overkill_EIGENFUN <- gets.eigen.params(N_finite = N_finite, kappa = kappa, alpha = alpha, graph = overkill_graph)$EIGENFUN


FF_innerprod <- t(graph$fem_basis(overkill_graph$get_mesh_locations())) %*%
  overkill_graph$mesh$C %*%
  overkill_EIGENFUN %*%
  outer(1:length(coeff_FF), 
        1:length(time_seq), 
        function(i, j) coeff_FF[i] * g_sin(r = time_seq[j], A = AAA, omega = OMEGA))

FF_true <- EIGENFUN %*% outer(1:length(coeff_FF), 
                         1:length(time_seq), 
                         function(i, j) coeff_FF[i] * g_sin(r = time_seq[j], A = AAA, omega = OMEGA))

# Numerical solution
my_op_frac <- my.fractional.operators.frac(L, beta, C, scale.factor = kappa^2, m = m, time_step)

U_approx <- matrix(NA, nrow = nrow(C), ncol = length(time_seq))
U_approx[, 1] <- U_0

# Time-stepping loop
for (k in 1:(length(time_seq) - 1)) {
  U_approx[, k + 1] <- as.matrix(my.solver.frac(my_op_frac, my_op_frac$C %*% U_approx[, k] + time_step * FF_innerprod[, k + 1]))
}

error <- sqrt(as.double(t(graph$mesh$weights) %*% (U_true - U_approx)^2 %*% rep(time_step, ncol(U_true))))
print(paste0("Total error = ", formatC(error, format = "f", digits = 9)))
```

```{r}
aux_graph <- gets.graph.tadpole(h = 0.01)
A_proj <- graph$fem_basis(aux_graph$get_mesh_locations())
FF_true <- A_proj %*% FF_true
U_true <- A_proj %*% U_true
U_approx <- A_proj %*% U_approx
```


```{r, fig.height = 6, out.width = "100%", fig.cap = captioner("Time evolution of the right-hand side function $f$.")}
start_idx <- which.min(abs(time_seq - 0.5))
end_idx <- which.min(abs(time_seq - 1.5))
idx <- start_idx:end_idx
graph.plotter.3d.single(aux_graph, FF_true[, idx], time_seq[idx])
```


```{r, fig.height = 6, out.width = "100%", fig.cap = captioner("Time evolution of the absolute difference between the exact and approximate solution.")}
abs_error <- abs(U_true[, idx] - U_approx[, idx])
graph.plotter.3d.single(aux_graph, abs_error, time_seq[idx])
```


```{r, fig.height = 6, out.width = "100%", fig.cap = captioner("Comparison of the exact and approximate solution at selected time points.")}
idx2 <- seq(from = start_idx, to = end_idx, by = 10)
graph.plotter.3d.comparer(aux_graph, U_true[,idx2], U_approx[,idx2], time_seq[idx2])
```


## References

```{r}
grateful::cite_packages(output = "paragraph", out.dir = ".")
```

