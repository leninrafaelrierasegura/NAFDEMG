---
title: "Convergence in ùëö"
date: "Last modified: `r format(Sys.time(), '%d-%m-%Y.')`"
output:
  html_document:
    mathjax: "https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
    highlight: pygments
    theme: flatly
    code_folding: hide # class.source = "fold-hide" to hide code and add a button to show it
    df_print: paged
    # toc: true
    # toc_float:
    #   collapsed: true
    #   smooth_scroll: true
    number_sections: false
    fig_caption: true
    code_download: true
    css: visual.css
always_allow_html: true
bibliography: 
  - references.bib
  - grateful-refs.bib
header-includes:
  - \newcommand{\ar}{\mathbb{R}}
  - \newcommand{\llav}[1]{\left\{#1\right\}}
  - \newcommand{\pare}[1]{\left(#1\right)}
  - \newcommand{\Ncal}{\mathcal{N}}
  - \newcommand{\Vcal}{\mathcal{V}}
  - \newcommand{\Ecal}{\mathcal{E}}
  - \newcommand{\Wcal}{\mathcal{W}}
---


<div style="color: #2c3e50; text-align: right;">
********  
<strong>Press Show to reveal the code chunks.</strong>  

********
</div>


Let us set some global options for all code chunks in this document.


```{r}
# Create a clipboard button
source(here::here("clipboard.R")); clipboard
# Set seed for reproducibility
set.seed(1982) 
# Set global options for all code chunks
knitr::opts_chunk$set(
  # Disable messages printed by R code chunks
  message = TRUE,    
  # Disable warnings printed by R code chunks
  warning = TRUE,    
  # Show R code within code chunks in output
  echo = TRUE,        
  # Include both R code and its results in output
  include = TRUE,     
  # Evaluate R code chunks
  eval = TRUE,       
  # Enable caching of R code chunks for faster rendering
  cache = FALSE,      
  # Align figures in the center of the output
  fig.align = "center",
  # Enable retina display for high-resolution figures
  retina = 2,
  # Show errors in the output instead of stopping rendering
  error = TRUE,
  # Do not collapse code and output into a single block
  collapse = FALSE
)
# Start the figure counter
fig_count <- 0
# Define the captioner function
captioner <- function(caption) {
  fig_count <<- fig_count + 1
  paste0("Figure ", fig_count, ": ", caption)
}
# Define the function to truncate a number to two decimal places
truncate_to_two <- function(x) {
  floor(x * 10000) / 10000
}
```



```{r}
# remotes::install_github("davidbolin/rspde", ref = "devel")
# remotes::install_github("davidbolin/metricgraph", ref = "devel")
library(rSPDE)
library(MetricGraph)
library(grateful)

library(ggplot2)
library(reshape2)
library(plotly)
```


# Utilitary functions

```{r}
knitr::purl(here::here("functionality.Rmd"), output = here::here("functionality.R"))
source(here::here("functionality.R"))
```

```{r}
# Function to compute the eigenvalues and eigenfunctions
gets.eigen.params <- function(N_finite = 4, kappa = 1, alpha = 0.5, graph){
  EIGENVAL_ALPHA <- NULL
  EIGENFUN <- NULL
  for (j in 0:N_finite) {
      lambda_j_alpha <- (kappa^2 + (j*pi/2)^2)^(alpha/2)
      e_j <- tadpole.eig(j,graph)$phi
      EIGENVAL_ALPHA <- c(EIGENVAL_ALPHA, lambda_j_alpha)         
      EIGENFUN <- cbind(EIGENFUN, e_j)
      if (j>0 && (j %% 2 == 0)) {
        lambda_j_alpha <- (kappa^2 + (j*pi/2)^2)^(alpha/2)
        e_j <- tadpole.eig(j,graph)$psi
        EIGENVAL_ALPHA <- c(EIGENVAL_ALPHA, lambda_j_alpha)         
        EIGENFUN <- cbind(EIGENFUN, e_j)
      }
  }
  return(list(EIGENVAL_ALPHA = EIGENVAL_ALPHA,
              EIGENFUN = EIGENFUN))
}

g_linear <- function(r, A, lambda_j_alpha_half) {
  return(A * exp(-lambda_j_alpha_half * r))
  }
G_linear <- function(t, A) {
  return(A * t)
  }
g_exp <- function(r, A, mu) {
  return(A * exp(mu * r))
  }
G_exp <- function(t, A, lambda_j_alpha_half, mu) {
  exponent <- lambda_j_alpha_half + mu
  return(A * (exp(exponent * t) - 1) / exponent)
  }
g_poly <- function(r, A, n) {
  return(A * r^n)
}
G_poly <- function(t, A, lambda_j_alpha_half, n) {
  t <- as.vector(t)
  k_vals <- 0:n
  sum_term <- sapply(t, function(tt) {
    sum(((-lambda_j_alpha_half * tt)^k_vals) / factorial(k_vals))
  })
  coeff <- ((-1)^(n + 1)) * factorial(n) / (lambda_j_alpha_half^(n + 1))
  return(A * coeff * (1 - exp(lambda_j_alpha_half * t) * sum_term))
}
g_sin <- function(r, A, omega) {
  return(A * sin(omega * r))
}
G_sin <- function(t, A, lambda_j_alpha_half, omega) {
  denom <- lambda_j_alpha_half^2 + omega^2
  numerator <- exp(lambda_j_alpha_half * t) * (lambda_j_alpha_half * sin(omega * t) - omega * cos(omega * t)) + omega
  return(A * numerator / denom)
}
g_cos <- function(r, A, theta) {
  return(A * cos(theta * r)) 
}
G_cos <- function(t, A, lambda_j_alpha_half, theta) {
  denom <- lambda_j_alpha_half^2 + theta^2
  numerator <- exp(lambda_j_alpha_half * t) * (lambda_j_alpha_half * cos(theta * t) + theta * sin(theta * t)) - lambda_j_alpha_half
  return(A * numerator / denom)
}
construct_piecewise_projection <- function(projected_U_approx, time_seq, overkill_time_seq) {
  projected_U_piecewise <- matrix(NA, nrow = nrow(projected_U_approx), ncol = length(overkill_time_seq))
  
  # Assign value at t = 0
  projected_U_piecewise[, which(overkill_time_seq == 0)] <- projected_U_approx[, 1]
  
  # Assign values for intervals (t_{k-1}, t_k]
  for (k in 2:length(time_seq)) {
    idxs <- which(overkill_time_seq > time_seq[k - 1] & overkill_time_seq <= time_seq[k])
    projected_U_piecewise[, idxs] <- projected_U_approx[, k]
  }
  
  return(projected_U_piecewise)
}
exp_line_equation <- function(x1, y1, rate) {
  lnC <- log(y1) - rate * x1
  
  function(x) {
    exp(lnC + rate * x)
  }
}
compute_guiding_lines_exp <- function(sqrt_m_vector, rate_vector, errors_projected) {
  guiding_lines <- matrix(NA, nrow = length(sqrt_m_vector), ncol = length(rate_vector))
  
  for (j in seq_along(rate_vector)) {
    guiding_lines_aux <- matrix(NA, nrow = length(sqrt_m_vector), ncol = length(sqrt_m_vector))
    
    for (k in seq_along(sqrt_m_vector)) {
      x1 <- sqrt_m_vector[k]
      y1 <- errors_projected[k, j]
      rate <- rate_vector[j]
      
      line <- exp_line_equation(x1, y1, rate)
      guiding_lines_aux[, k] <- line(sqrt_m_vector)
    }
    
    guiding_lines[, j] <- rowMeans(guiding_lines_aux)
  }
  
  return(guiding_lines)
}
```


We want to solve the fractional diffusion equation
\begin{equation}
\label{eq:maineq}
    \partial_t u+(\kappa^2-\Delta_\Gamma)^{\alpha/2} u=f \text { on } \Gamma \times(0, T), \quad u(0)=u_0 \text { on } \Gamma,
\end{equation}
where $u$ satisfies the Kirchhoff vertex conditions
\begin{equation}
\label{eq:Kcond}
    \left\{\phi\in C(\Gamma)\;\Big|\; \forall v\in V: \sum_{e\in\mathcal{E}_v}\partial_e \phi(v)=0 \right\}
\end{equation}
The solution is given by
\begin{equation}
\label{eq:sol_reprentation}
        u(s,t) = \displaystyle\sum_{j\in\mathbb{N}}e^{-\lambda^{\alpha/2}_jt}\left(u_0, e_j\right)_{L_2(\Gamma)}e_j(s) + \int_0^t \displaystyle\sum_{j\in\mathbb{N}}e^{-\lambda^{\alpha/2}_j(t-r)}\left(f(\cdot, r), e_j\right)_{L_2(\Gamma)}e_j(s)dr.
\end{equation}

If we choose $w_j$ and $v_j$ and take the initial condition and the right hand side funciton as 

\begin{equation}
    u_0(s) = \sum_{j=0}^{N} w_j e_j(s) \text{ and so } \left(u_0, e_j\right)_{L_2(\Gamma)} = w_j,
\end{equation}
\begin{equation}
   \text{In matrix notation: } \quad\boldsymbol{U}_0 = \boldsymbol{E}_h\boldsymbol{c}, \quad  \boldsymbol{E}_h = \left[e_0, e_1, \ldots, e_{N}\right], \quad \boldsymbol{w} = \left[w_0, w_1, \ldots, w_{N}\right]^\top,
\end{equation}
\begin{equation}
   \text{In } \texttt{R}: \texttt{U_0 <- EIGENFUN %*% coeff_U_0}
\end{equation}
and
\begin{equation}
    f(s,t) = \sum_{j=0}^{N} v_j e^{-\lambda^{\alpha/2}_jt} e_j(s) \text{ and so } \left(f(\cdot,r), e_j\right)_{L_2(\Gamma)} = v_j e^{-\lambda^{\alpha/2}_jr},
\end{equation}
\begin{equation}
   \text{In matrix notation: } \quad\boldsymbol{f} = \boldsymbol{E}_h \boldsymbol{V}, \quad \boldsymbol{V}_{ji} = v_je^{-\lambda^{\alpha/2}_jt_i}
\end{equation}
\begin{equation}
   \text{In } \texttt{R}: \texttt{FF <- EIGENFUN %*% (coeff_FF * exp(-outer(EIGENVAL_ALPHA, time_seq)))}
\end{equation}
then the solution is given by
\begin{align}
        u(s,t) &= \displaystyle\sum_{j=0}^{N}w_je^{-\lambda^{\alpha/2}_jt}e_j(s) + \int_0^t \displaystyle\sum_{j=0}^Ne^{-\lambda^{\alpha/2}_j(t-r)}v_j e^{-\lambda^{\alpha/2}_jr}e_j(s)dr\\
        &= \displaystyle\sum_{j=0}^{N}w_je^{-\lambda^{\alpha/2}_jt}e_j(s) + t \displaystyle\sum_{j=0}^Nv_j e^{-\lambda^{\alpha/2}_jt}e_j(s)\\
        &= \displaystyle\sum_{j=0}^{N}w_je^{-\lambda^{\alpha/2}_jt}e_j(s) + tf(s,t)\\
        &= \displaystyle\sum_{j=0}^{N}(w_j+tv_j)e^{-\lambda^{\alpha/2}_jt}e_j(s) 
\end{align}

\begin{equation}
   \text{In matrix notation: } \quad\boldsymbol{U} =\boldsymbol{E}_h \boldsymbol{W} + (\boldsymbol{t}\boldsymbol{f}^\top)^\top, \quad \boldsymbol{W}_{ji} = w_je^{-\lambda^{\alpha/2}_jt_i},\quad \boldsymbol{t} = \left[t_0, t_1, \ldots, t_{K}\right]^\top
\end{equation}
\begin{equation}
   \text{In } \texttt{R}: \texttt{U_true <- EIGENFUN %*% (coeff_U_0 * exp(-outer(EIGENVAL_ALPHA, time_seq)))+ t(time_seq * t(FF))}
\end{equation}

```{r}
# Parameters
T_final <- 2
kappa <- 15
N_finite = 4 # choose even
adjusted_N_finite <- N_finite + N_finite/2 + 1
# Coefficients for u_0 and f
coeff_U_0 <- 50*(1:adjusted_N_finite)^-1
coeff_U_0[-5] <- 0
coeff_FF <- rep(0, adjusted_N_finite)
coeff_FF[7] <- 10

AAA = 1
MU = 0.3
NNN = 2
OMEGA = pi
THETA = pi

# Time step and mesh size
m_vector <- c(1, 2, 3, 4)
    
# Overkill parameters
overkill_time_step <- 0.1 * 2^-14
overkill_h <- (0.1 * 2^-14)^(1/2)

# Finest time and space mesh
overkill_time_seq <- seq(0, T_final, length.out = ((T_final - 0) / overkill_time_step + 1))
overkill_graph <- gets.graph.tadpole(h = overkill_h)

# Compute the weights on the finest mesh
overkill_graph$compute_fem() # This is needed to compute the weights
overkill_weights <- overkill_graph$mesh$weights

alpha_vector <- seq(1, 1.8, by = 0.2)#c(0.5, 1, 1.5, 2)
```


```
{r}
# Create a matrix to store the errors
errors_projected <- matrix(NA, nrow = length(m_vector), ncol = length(alpha_vector))
for (j in 1:length(alpha_vector)) {
  alpha <- alpha_vector[j] # from 0.5 to 2
  beta <- alpha / 2

  # Compute the eigenvalues and eigenfunctions on the finest mesh
  overkill_eigen_params <- gets.eigen.params(N_finite = N_finite, kappa = kappa, alpha = alpha, graph = overkill_graph)
  EIGENVAL_ALPHA <- overkill_eigen_params$EIGENVAL_ALPHA # Eigenvalues (they are independent of the meshes)
  overkill_EIGENFUN <- overkill_eigen_params$EIGENFUN # Eigenfunctions on the finest mesh
  
  # Compute the true solution on the finest mesh
  overkill_U_true <- overkill_EIGENFUN %*% 
    outer(1:length(coeff_U_0), 
          1:length(overkill_time_seq), 
          function(i, j) (coeff_U_0[i] + coeff_FF[i] * G_sin(t = overkill_time_seq[j], A = AAA, lambda_j_alpha_half = EIGENVAL_ALPHA[i], omega = OMEGA)) * exp(-EIGENVAL_ALPHA[i] * overkill_time_seq[j]))
  
  for (i in 1:length(m_vector)) {
    m <- m_vector[i]
    h <- exp(- (4 * pi / 5) * sqrt((1 - alpha / 2) * m))/10
    time_step <- (h^alpha)/10
    graph <- gets.graph.tadpole(h = h)
    graph$compute_fem()
    G <- graph$mesh$G
    C <- graph$mesh$C
    L <- kappa^2*C + G
    eigen_params <- gets.eigen.params(N_finite = N_finite, kappa = kappa, alpha = alpha, graph = graph)
    EIGENFUN <- eigen_params$EIGENFUN
    U_0 <- EIGENFUN %*% coeff_U_0 # Compute U_0 on the current mesh
    A <- graph$fem_basis(overkill_graph$get_mesh_locations())
  
    time_seq <- seq(0, T_final, length.out = ((T_final - 0) / time_step + 1))
    my_op_frac <- my.fractional.operators.frac(L, beta, C, scale.factor = kappa^2, m = m, time_step)
    INT_BASIS_EIGEN <- t(overkill_EIGENFUN) %*% overkill_graph$mesh$C %*% A
    # Compute matrix F with columns F^k
    FF_approx <- t(INT_BASIS_EIGEN) %*% 
      outer(1:length(coeff_FF), 
            1:length(time_seq), 
        function(i, j) coeff_FF[i] * g_sin(r = time_seq[j], A = AAA, omega = OMEGA))
    
    U_approx <- matrix(NA, nrow = nrow(C), ncol = length(time_seq))
    U_approx[, 1] <- U_0
    for (k in 1:(length(time_seq) - 1)) {
      U_approx[, k + 1] <- as.matrix(my.solver.frac(my_op_frac, my_op_frac$C %*% U_approx[, k] + time_step * FF_approx[, k + 1]))
    }
    
    projected_U_approx <- A %*% U_approx
    projected_U_piecewise <- construct_piecewise_projection(projected_U_approx, time_seq, overkill_time_seq)
    errors_projected[i,j] <- sqrt(as.double(t(overkill_weights) %*% (overkill_U_true - projected_U_piecewise)^2 %*% rep(overkill_time_step, length(overkill_time_seq))))
  }
}
save(errors_projected, file = here::here("data_files/errors_projected_m.RData"))
```

```{r}
load(here::here("data_files/errors_projected_m.RData"))
```


```{r, fig.align='center', fig.dim= c(4,5), fig.cap = captioner("Caption")}
observed_rates <- numeric(length(alpha_vector))
for (u in 1:length(alpha_vector)) {
  observed_rates[u] <- coef(lm(log(errors_projected[, u]) ~ sqrt(m_vector)))[2]
}

theoretical_rates <- - (4 * pi * alpha_vector / 5) * sqrt((1 - alpha_vector / 2))

guiding_lines <- compute_guiding_lines_exp(sqrt(m_vector), theoretical_rates, errors_projected)
default_colors <- scales::hue_pal()(length(alpha_vector))
plot_lines <- lapply(1:ncol(guiding_lines), function(i) {
  geom_line(
    data = data.frame(x = sqrt(m_vector), y = guiding_lines[, i]),
    aes(x = x, y = y),
    color = default_colors[i],
    linetype = "dashed",
    show.legend = FALSE
  )
})

df <- as.data.frame(cbind(sqrt(m_vector), errors_projected))
colnames(df) <- c("m_vector", alpha_vector)
df_melted <- melt(df, id.vars = "m_vector", variable.name = "column", value.name = "value")
alpha_formatted <- formatC(alpha_vector, format = "f", digits = 2)
custom_labels <- paste0(alpha_formatted, 
                        " | ", 
                        formatC(theoretical_rates, format = "f", digits = 4), 
                        " | ", 
                        formatC(observed_rates, format = "f", digits = 4))

df_melted$column <- factor(df_melted$column, levels = alpha_vector, labels = custom_labels)

p <- ggplot() +
  geom_line(data = df_melted, aes(x = m_vector, y = value, color = column)) +
  geom_point(data = df_melted, aes(x = m_vector, y = value, color = column)) +
  plot_lines +
  labs(
    title = expression("Convergence in " * italic(m)),
    x = expression(italic(m)~(sqrt~scale)),
    y = expression(Error~(log[e]~scale)),
    color = "          Œ±  | theo  | obs"
  ) +
  scale_x_continuous(breaks = sqrt(m_vector), labels = round(m_vector, 4)) +
  scale_y_continuous(
  trans = "log",
  labels = function(x) formatC(x, format = "f", digits = 4)) +
  theme_minimal() +
  theme(text = element_text(family = "Palatino"),
        legend.position = "bottom",
        legend.direction = "vertical",
        plot.margin = margin(0, 0, 0, 0),
        plot.title = element_text(hjust = 0.5, size = 18, face = "bold"))
p
```


```{r}
ggsave(here::here("data_files/conv_rates_m.png"), width = 4, height = 5, plot = p, dpi = 300)
```


